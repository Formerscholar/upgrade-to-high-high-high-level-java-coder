## 不同的事务隔离级别带来的问题

> 在两个手动开启的事务之间，且两个事务并行时的隔离



#### 几个概念

1. 脏读

   A事务先<font color="red">不带锁的读取</font>了一次数据，此时B事务执行了一次数据操作，A事务再<font color="red">不带锁的读取</font>一次数据，发现跟前一次读取的数据不一致，然后B事务又执行了一次操作，A事务再<font color="red">不带锁的读取</font>一次数据，发现又跟前一次读取的数据不一致，最后B事务执行回滚，A事务再去<font color="red">不带锁的读取</font>发现之前读到的数据又改掉了，这就是脏读。

2. 不可重复读

   A事务先<font color="red">不带锁的读取</font>了一次数据数据，然后此时B事务修改了其中的数据并提交了，然后A事务又<font color="red">不带锁的读取</font>了一次数据，发现2次读取的数据不一致，这就是不可重复读。

3. 幻读

   A事务先<font color="red">不带锁的读取</font>了一次数据，然后此时B事务新增了一条数据并执行了事务提交，然后A事务Update了一次数据（B事务提交的数据也要被包含在update数据中），然后A事务再去<font color="red">不带锁的读取</font>一次数据发现跟前一次读取的数据不一致，这就是幻读。我们使用间隙锁来解决幻读问题。



#### 不同的隔离级别带来不同的问题

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 读未提交 |  是  |     是     |  是  |
| 读已提交 |  否  |     是     |  是  |
| 可重复读 |  否  |     否     |  是  |
|  串行化  |  否  |     否     |  否  |



